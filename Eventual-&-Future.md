# Introduction
A future, an eventual, or a _promise_, is a mechanism for passing a value between threads, allowing a thread to wait for a value that is set asynchronously. It is used to increase concurrency in a parallel program. This construction is really popular in functional programming languages, in particular MultiLisp. If the programmer defines a future containing an expression, the runtime system _promises_ to evaluate that expression concurrently. The resulting value of the expression might not be available immediately, but it will be eventually computed. Therefore, futures also require a synchronization interface between the program and the multiple concurrent threads that may be computing portions of the code. In Argobots, futures are used with the purpose of synchronizing execution between cooperating concurrent ULTs. There are two basic mechanisms implemented, eventuals and futures.

Future、Eventual 或 Promise 是一种在线程之间传递值的机制，允许线程等待异步设置的值。 它用于提高并行程序中的并发性。 这种结构在函数式编程语言中非常流行，尤其是 MultiLisp。 如果程序员定义了一个包含表达式的未来，运行时系统承诺同时计算该表达式。 表达式的结果值可能不会立即可用，但最终会被计算出来。 因此，futures 还需要程序和可能计算部分代码的多个并发线程之间的同步接口。 在 Argobots 中，futures 用于同步协作并发 ULT 之间的执行。 实施了两种基本机制，eventuals 和 futures。

In Argobots, _eventual_ corresponds to the traditional behavior of the future concept. A ULT creates an eventual, which is a memory buffer that will eventually contain a value of interest. Many ULTs can wait on the eventual (a blocking call), until one ULT signals on that future.

在 Argobots 中，eventual 对应于 future 概念的传统行为。 ULT 创建一个最终的，它是一个内存缓冲区，最终将包含一个感兴趣的值。 许多 ULT 可以等待最终结果（一个阻塞调用），直到一个 ULT 发出那个未来信号。

_Future_ in Argobots has a slightly different behavior. A future is created with a number of _compartments_. Each of those _k_ compartments will be set by contributing ULTs. Any other ULT will block on a future until all the compartments have been set. In some sense, a future is a multiple-buffer extension of an eventual. Eventuals and futures have a different philosophy of memory management. An eventual will create and destroy the memory buffer that will hold a result. In contrast, a future does not create any buffer. Therefore, a future assumes each contributing ULT allocates and destroys all memory buffers. When a contributing ULT sets a value, it just passes a pointer to the particular memory location.

Argobots 中的 Future 行为略有不同。 未来是用许多隔间创建的。 这 k 个隔间中的每一个都将通过提供 ULT 来设置。 任何其他 ULT 都将阻塞未来，直到所有隔间都已设置。 从某种意义上说，future 是 eventual 的多缓冲区扩展。 Eventuals 和 futures 有不同的内存管理理念。 最终将创建和销毁将保存结果的内存缓冲区。 相反，未来不会创建任何缓冲区。 因此，未来假设每个贡献的 ULT 都分配并销毁所有内存缓冲区。 当贡献的 ULT 设置一个值时，它只是传递一个指向特定内存位置的指针。