# Introduction
A future, an eventual, or a _promise_, is a mechanism for passing a value between threads, allowing a thread to wait for a value that is set asynchronously. It is used to increase concurrency in a parallel program. This construction is really popular in functional programming languages, in particular MultiLisp. If the programmer defines a future containing an expression, the runtime system _promises_ to evaluate that expression concurrently. The resulting value of the expression might not be available immediately, but it will be eventually computed. Therefore, futures also require a synchronization interface between the program and the multiple concurrent threads that may be computing portions of the code. In Argobots, futures are used with the purpose of synchronizing execution between cooperating concurrent ULTs. There are two basic mechanisms implemented, eventuals and futures.

In Argobots, _eventual_ corresponds to the traditional behavior of the future concept. A ULT creates an eventual, which is a memory buffer that will eventually contain a value of interest. Many ULTs can wait on the eventual (a blocking call), until one ULT signals on that future.

_Future_ in Argobots has a slightly different behavior. A future is created with a number of _compartments_. Each of those _k_ compartments will be set by contributing ULTs. Any other ULT will block on a future until all the compartments have been set. In some sense, a future is a multiple-buffer extension of an eventual. Eventuals and futures have a different philosophy of memory management. An eventual will create and destroy the memory buffer that will hold a result. In contrast, a future does not create any buffer. Therefore, a future assumes each contributing ULT allocates and destroys all memory buffers. When a contributing ULT sets a value, it just passes a pointer to the particular memory location.